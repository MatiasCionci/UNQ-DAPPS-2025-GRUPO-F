package com.dappstp.dappstp.model.queryhistory;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.time.LocalDateTime;
import static org.junit.jupiter.api.Assertions.*;

class PredictionLogTest {

    private String requestData;
    private String predictionResult;
    private String predictionType;
    private LocalDateTime fixedTime;

    @BeforeEach
    void setUp() {
        requestData = "{\"matchId\": 123, \"teamA_power\": 75, \"teamB_power\": 80}";
        predictionResult = "{\"winner\": \"TeamB\", \"confidence\": 0.65}";
        predictionType = "MATCH_WINNER_V1";
        fixedTime = LocalDateTime.of(2023, 10, 26, 10, 30, 0); // A fixed time for consistent tests
    }

    @Test
    void testNoArgsConstructor() {
        PredictionLog log = new PredictionLog();
        assertNotNull(log);
        assertNull(log.getId());
        assertNull(log.getRequestData());
        assertNull(log.getPredictionResult());
        assertNull(log.getPredictionType());
        assertNull(log.getCreatedAt());
    }

    @Test
    void testConstructorWithParameters() {
        // To test the constructor accurately, we need to control createdAt or accept its nature
        PredictionLog log = new PredictionLog(requestData, predictionResult, predictionType);

        assertNull(log.getId()); // ID is generated by DB
        assertEquals(requestData, log.getRequestData());
        assertEquals(predictionResult, log.getPredictionResult());
        assertEquals(predictionType, log.getPredictionType());
        assertNotNull(log.getCreatedAt());
        // Check if createdAt is very recent (e.g., within the last few seconds)
        assertTrue(log.getCreatedAt().isAfter(LocalDateTime.now().minusSeconds(5)));
        assertTrue(log.getCreatedAt().isBefore(LocalDateTime.now().plusSeconds(1)));
    }

    @Test
    void testGettersAndSetters() {
        PredictionLog log = new PredictionLog();

        log.setId(1L);
        log.setRequestData(requestData);
        log.setPredictionResult(predictionResult);
        log.setPredictionType(predictionType);
        log.setCreatedAt(fixedTime);

        assertEquals(1L, log.getId());
        assertEquals(requestData, log.getRequestData());
        assertEquals(predictionResult, log.getPredictionResult());
        assertEquals(predictionType, log.getPredictionType());
        assertEquals(fixedTime, log.getCreatedAt());
    }

    @Test
    void testEqualsAndHashCode() {
        // Lombok @Data should handle this. Test based on ID if it's the primary differentiator for equals/hashCode.
        // If not, it will compare all fields.
        PredictionLog log1 = new PredictionLog(requestData, predictionResult, predictionType);
        log1.setId(1L);
        log1.setCreatedAt(fixedTime);

        PredictionLog log2 = new PredictionLog(requestData, predictionResult, predictionType);
        log2.setId(1L);
        log2.setCreatedAt(fixedTime);

        PredictionLog log3 = new PredictionLog("otherData", "otherResult", "otherType");
        log3.setId(2L);
        log3.setCreatedAt(fixedTime.plusHours(1));

        assertEquals(log1, log2);
        assertEquals(log1.hashCode(), log2.hashCode());
        assertNotEquals(log1, log3);
    }
}